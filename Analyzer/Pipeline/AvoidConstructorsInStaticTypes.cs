/******************************************************************************
* Filename    = AvoidConstructorsInStaticTypes.cs
* 
* Author      = Yukta Salunkhe
* 
* Project     = Analyzer
*
* Description = This Analyzer throws error if any class with all static members have a public non-static constructor.
*****************************************************************************/

using Analyzer.Parsing;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;


namespace Analyzer.Pipeline
{
    /// <summary>
    /// This class represents an analyzer which check if a class containing all static fields and methods has a public not static constructor
    /// </summary>
    public class AvoidConstructorsInStaticTypes : AnalyzerBase
    {
        // Unique identifier for the analyzer
        private string _errorMessage;
        private int _verdict;

        // Set to store classes violating the rule
        public HashSet<ParsedClass> violatingClasses = null;

        /// <summary>
        /// Initializes a new instance of the AvoidConstructorsWithStaticTypes analyzer with parsed DLL files.
        /// </summary>
        /// <param name="dllFiles"></param>
        public AvoidConstructorsInStaticTypes( List<ParsedDLLFile> dllFiles ) : base( dllFiles )
        {
            Trace.WriteLine("Created Instance of Analyzer AvoidConstructorsInStaticTypes");
            _analyzerID = "102";
            _errorMessage = string.Empty;
        }

        /// <summary>
        /// Checks if all methods and fields of a class are static or not
        /// </summary>
        /// <param name="cls"></param>
        /// <returns>True if all methods and fields in the class are static, else returns False</returns>
        public bool CheckAllStatic( ParsedClass cls )
        {
            // Get all methods in the class
            MethodInfo[] methods = cls.TypeObj.GetMethods();

            //if any method is not declared as static, return false immediately.
            if (methods.Length != 0)
            {
                foreach (MethodInfo method in methods)
                {
                    if (method == null)
                    {
                        continue;
                    }

                    Type? declaringType = method.DeclaringType;
                    if ((declaringType != null) && (declaringType.ToString().StartsWith( "System.Object" )))
                    {
                        continue;
                    }

                    if (!method.IsStatic)
                    {
                        return false;
                    }
                }
            }

            // Get all fields in the class
            FieldInfo[] fields = cls.TypeObj.GetFields();

            if (fields.Length != 0)
            {
                foreach (FieldInfo? field in fields)
                {
                    if (!field.IsStatic)
                    {
                        return false;
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// Constructs the AnalyzerResult object based on the analysis.
        /// </summary>
        /// <param name="parsedDLLFile"></param>
        protected override AnalyzerResult AnalyzeSingleDLL( ParsedDLLFile parsedDLLFile )
        {
            Trace.WriteLine("Running Analyzer AvoidConstructorInStaticTypes on " + parsedDLLFile.DLLFileName);
            _errorMessage = "";
            _verdict = 1;
            violatingClasses = new HashSet<ParsedClass>();

            foreach (ParsedClass cls in parsedDLLFile.classObjList)
            {
                if (cls==null || cls.TypeObj == null || cls.TypeObj.IsGenericType || IsAutoGenerated(cls.TypeObj))
                {
                    continue;
                }

                // Check if all methods and fields in the class are static
                bool isAllStatic = CheckAllStatic( cls );

                // If all methods and fields are static, check constructors
                if (isAllStatic)
                {
                    foreach (ConstructorInfo constructor in cls.Constructors)
                    {
                        //checking if any parameterized constructor is not declared static
                        if (constructor.GetParameters().Length > 0)
                        {
                            continue;
                        }
                        //default constructor should be declared static or private to avoid violations
                        if (!constructor.IsStatic && !constructor.IsPrivate)
                        {
                            violatingClasses.Add( cls );
                        }
                    }
                }
            }

            //If any class violates the rule, return verdict as 0 (Failed), else 1 (Passed)
            int violations = violatingClasses.Count;
            if (violations > 0)
            {
                _verdict = 0;
            }

            if (_verdict != 0)
            {
                _verdict = 1;
                _errorMessage = "No violation found";
                Trace.WriteLine("Analysis completed for " + parsedDLLFile.DLLFileName);
                return new AnalyzerResult( analyzerID , _verdict , _errorMessage );
            }

            //adding error message
            _errorMessage = "Classes ";
            foreach (ParsedClass cls in violatingClasses)
            {
                _errorMessage += cls.TypeObj.FullName;
                violations--;
                if (violations != 0)
                {
                    _errorMessage += ", ";
                }
            }
            _errorMessage += " contains only static fields and methods, but has non-static, visible constructor. Try changing it to private or make it static.";

            //Return the AnalyzerResult object, with appropriate error mesaage.
            AnalyzerResult resultObj = new( analyzerID , _verdict , _errorMessage );
            Trace.WriteLine("Analysis completed for " + parsedDLLFile.DLLFileName);
            return resultObj;
        }

        private static bool IsAutoGenerated( Type type )
        {
            try
            {
                return type.IsDefined( typeof( CompilerGeneratedAttribute ) , false );
            }
            catch ( Exception e )
            {
                Trace.WriteLine(e.Message);
                return false;
            }
        }
    }
}

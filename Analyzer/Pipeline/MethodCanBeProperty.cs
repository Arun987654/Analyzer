using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Analyzer.Parsing;
using Mono.Cecil.Cil;
using Mono.Cecil;
using Mono.Cecil.Rocks;

namespace Analyzer.Pipeline
{
    public class MethodCanBeProperty : AnalyzerBase
    {
        private string _errorMessage;
        private int _verdict;
        private readonly string _analyzerID;

        static readonly string[] whitelist = { "GetEnumerator",
                            "GetHashCode",
                            "GetType",
                            "GetTypeCode",
                            "GetValue",
                            "HasElementTypeImpl"};
        private const string Void = "System.Void";
        string[] parameter = new string[1];

        public MethodCanBeProperty(List<ParsedDLLFile> dllFiles) : base(dllFiles)
        {
            _errorMessage = "";
            _verdict = 1;
            _analyzerID = "101";
        }

        public List<Type> CheckMethod(ParsedDLLFile parsedDLLFile)
        {
            // rules do not apply to constructors, methods returning an array, properties
            if (method.IsConstructor || method.IsSpecialName)
                return RuleResult.DoesNotApply;

            // we don't apply the rule to overrides since the base method can be
            // outside the developer's control (and if not this is the *one* that
            // should be reported)
            if (method.IsVirtual && !method.IsNewSlot)
                return RuleResult.DoesNotApply;

            // ignore methods returning arrays
            TypeReference return_type = method.ReturnType;
            if (return_type.IsArray)
                return RuleResult.DoesNotApply;

            // rules do not apply to code generated by the compiler (e.g. anonymous methods)
            // or generated by a tool (e.g. web services)
            if (method.IsGeneratedCode())
                return RuleResult.DoesNotApply;
            string name = method.Name;
            // ignore the some common Get* method names used in the framework
            foreach (string s in whitelist)
            {
                if (name == s)
                    return RuleResult.DoesNotApply;
            }

            // rule applies

            // If it starts with "get" or "is" or "has", has no parameters and returns something
            bool get = name.StartsWith("get", StringComparison.OrdinalIgnoreCase);
            bool isp = name.StartsWith("is", StringComparison.OrdinalIgnoreCase);
            bool has = name.StartsWith("has", StringComparison.OrdinalIgnoreCase);
            if ((get || isp || has) && !method.HasParameters && !return_type.IsNamed("System", "Void"))
            {
                return RuleResult.Failure;
            }

            return RuleResult.Success;
        }

        private string ErrorMessage(List<Type> abstractTypesWithPublicConstructor)
        {
            var errorLog = new System.Text.StringBuilder("The following abstract classes have public constructors:");

            foreach (Type type in abstractTypesWithPublicConstructor)
            {
                try
                {
                    // sanity check
                    errorLog.AppendLine(type.Name.ToString());
                }
                catch (ArgumentOutOfRangeException ex)
                {
                    throw new ArgumentOutOfRangeException("Invalid Argument ", ex);
                }

            }
            return errorLog.ToString();
        }

        protected override AnalyzerResult AnalyzeSingleDLL(ParsedDLLFile parsedDLLFile)
        {
            _errorMessage = "";
            _verdict = 1;

            List<Type> MethodsThatCanBeProperties = CheckMethod(parsedDLLFile);
            if (MethodsThatCanBeProperties.Count > 0)
            {
                _verdict = 0;
                _errorMessage = ErrorMessage(MethodsThatCanBeProperties);
            }
            return new AnalyzerResult(_analyzerID, _verdict, _errorMessage);
        }
    }
}
